Prime factorisation involves finding every factor of a number, that can only be divisible by one and itself.
The first step of my prime factorisation algorithm is to take in a number and see if it has a factor of 2. This is done using the modulus operator, which returns the remainder left when one number is divided by another.
If the given value modulus 2 returns a value of 0 (and the given value itself is not 0) it means that the value divided by 2 returns a whole number and - as 2 is a prime number - 2 would therefore be a prime factor of the given value. Add the number 2 to the list of prime factors, then divide the given value by 2 and store the new value. The number is divided by two as now two has been found as a factor the algorithm needs the new value to find the other factors. Repeat this until the expression (value modulus 2) does not return 0, meaning that 2 is not a prime factor of the current value and is not another factor of the original value. 
Error handling should be introduced so that if the given value was 0, the program would exit the loop. 0 divided by 2 is zero and if the algorithm does not take this possibility into consideration then there could be an infinite loop. If the original value was zero then the value modulus 2 AND the value divided by 2 would always equal 0 and the algorithm would never exit the loop. 
After this, use another loop with an integer value (e.g. 'i') starting at the value 3 and increasing in multiples of 2, checking each value to see if it is a prime factor. The loop will be completed while the current value is greater than the value of 'i' squared. For every value of 'i', check if the current value modulus 'i' is equal to 0. If it is then this means 'i' is a prime factor and it will be added to the list of prime factors. The current value will then be divided by 'i' and the loop will restart. 
‘i’ is started at 3 as this is the next possible prime factor for the given value after 2 and then it is increased by 2 each time as no even number can be a prime factor (except 2) and any odd number that is not a prime number will have a lower (prime) odd number as a factor and thus no non-prime numbers would be added to the list of factors. For example, any number that has a factor of 9 will also have a factor of 3, and as 3 is smaller than 9, it will be checked first and the value would be changed so that 9 would never be added to the list of prime factors.
The loop will continue until the current value is no longer higher than 'i' squared as this is when there are no further factors (other than possibly the current value itself.) There can only be at most one prime factor greater than the square root of the value and this is caught by the last section of the algorithm. If the current value - after the loop - is still greater than 2, this means it is also a prime factor of the original value and should be added to the list.
